################################################ Set Global Variables #################################################
# Global Variables
set NEURON_MEMORY_SIZE = 1;
set TYPE_SHOW = SHOW_FRAME;
set TYPE_MOVING_FRAME = STOP;

# Camera Parameters
set CAMERA_DISTANCE = 6.9; # [cm]
#set FOCAL_DISTANCE  = 400.0; # [pixels]

######################################################## Constants ####################################################
#### INPUT & Neuron Layer Dimentions
const INPUT_WIDTH  = 320;
const INPUT_HEIGHT = 240;
const NL_WIDTH  = INPUT_WIDTH;
const NL_HEIGHT = INPUT_HEIGHT;

#### Camera Constants
const FOV_HORIZONTAL          = 47.05;
const FOV_VERTICAL            = 35.71;

#### TEST STIMULUS
const BACKGROUND_COLOR        = 128;
const STIMULUS_LEFT_COLOR     = 255;
const STIMULUS_RIGHT_COLOR    = 255;

#### Stimulos measurements [deg]
const STIMULUS_WIDTH          = 0.5;
const STIMULUS_HEIGHT         = 17.0;
const TEST_SCAN_WIDTH         = 5.0;

#### Inputs, Neuron & Outputs layers name´s
const INPUT_NAME_LEFT         = "image_left";
const INPUT_NAME_RIGHT        = "image_right";
#const NL_SIMPLE_MONO_RIGHT    = "nl_simple_mono_right";
#const NL_SIMPLE_MONO_RIGHT_Q  = "nl_simple_mono_right_q";
#const NL_SIMPLE_MONO_LEFT     = "nl_simple_mono_left";
#const NL_SIMPLE_MONO_LEFT_Q   = "nl_simple_mono_left_q";
#const NL_SIMPLE_BIONOCULAR    = "nl_simple_binocular";
#const NL_SIMPLE_BIONOCULAR_Q  = "nl_simple_binocular_q";
#const NL_COMPLEX_MONO_RIGHT   = "nl_complex_mono_right";
#const NL_COMPLEX_MONO_LEFT    = "nl_complex_mono_left";
#const NL_COMPLEX_BINOCULAR    = "nl_complex_binocular";
#const NL_MT                   = "nl_mt";
#const NL_MT_GAUSSIAN          = "nl_mt_gaussian";
#const NL_DISPARITY_MAP        = "nl_disparity_map";
#const OUT_DISPARITY_MAP       = "out_disparity_map";

#### Input data file name
const CAMERA_LEFT_PARAMETERS_FILE_NAME = "CameraLeftParameters.dat";
const CAMERA_RIGHT_PARAMETERS_FILE_NAME = "CameraRightParameters.dat";
const FILE_RBT_IMAGE_LEFT     = "img_left.rbt";
const FILE_RBT_IMAGE_RIGHT    = "img_right.rbt";

#### Output data file name
const FILE_PLOT_SIMPLE_M_R    = "s_m_r.out";
const FILE_PLOT_SIMPLE_M_R_Q  = "s_m_r_q.out";
const FILE_PLOT_SIMPLE_M_L    = "s_m_l.out";
const FILE_PLOT_SIMPLE_M_L_Q  = "s_m_l_q.out";
const FILE_PLOT_SIMPLE_B      = "s_b.out";
const FILE_PLOT_SIMPLE_B_Q    = "s_b_q.out";
const FILE_PLOT_COMPLEX_M_R   = "c_m_r.out";
const FILE_PLOT_COMPLEX_M_L   = "c_m_l.out";
const FILE_PLOT_COMPLEX_B     = "c_b.out";
const FILE_PLOT_MT            = "mt.out";
const FILE_PLOT_MT_GAUSSIAN   = "mt_g.out";
const FILE_PLOT_VERGENCE      = "vergence.out";
const FILE_PLOT_MT_CELL       = "mt_cell.out";

#### Index MT CELL (mt cell that will be ploted)
const INDEX_MT_CELL           = (NL_WIDTH * NL_HEIGHT / 2) + (NL_WIDTH / 2);

#### Network connection configuration
const SOCKET_PORT             = 27015;
const HOST_ADDR_MONO          = "192.168.0.1";
const HOST_ADDR_LEFT          = "10.50.5.121";
const HOST_ADDR_RIGHT         = "10.50.5.122";

const VISION_STEREO           = TRUE;

#### Application constants
const GET_IMAGE_FROM_SOCKET   = 0;
const GET_IMAGE_FROM_RBT      = 1;
const GET_IMAGE_FROM_PNM      = 2;
const GET_IMAGE_TEST_STIMULUS = 3;

const LOG_FACTOR              = 2.0;
const CYCLES_PER_DEGREE       = 0.85; # robot = 0.85 / test = 0.31
const MT_SENSIBILITY          = 0.1;
const SMOOTHNESS              = 1.0;
const CONTRAST_RATIO          = 10.0;

# Vergence parameters
const NEAREST_DISTANCE	= 1000.0; # [mm]
const FARTEST_DISTANCE	= 2500.0; # [mm]
const VERGENCE_BANDWITH	= 0.6; # 0.2 percentual de faixa de vergência

# Setup by compute_v1_spatial_receptive_field
const MAX_KERNEL_POINTS			= 2048; #256;

#### Kernel types
#const KERNEL_1D               = 0;
#const KERNEL_2D               = 1;

################################################# Inputs #######################################################
#input		image_left[INPUT_WIDTH][INPUT_HEIGHT]		with color outputs produced by input_generator("%d", GET_IMAGE_FROM_SOCKET) controled by input_controler();
#input		image_right[INPUT_WIDTH][INPUT_HEIGHT]		with color outputs produced by input_generator("%d", GET_IMAGE_FROM_SOCKET) controled by input_controler();

#input		image_left[INPUT_WIDTH][INPUT_HEIGHT]		with color outputs produced by input_generator("%d", GET_IMAGE_FROM_PNM) controled by input_controler();
#input		image_right[INPUT_WIDTH][INPUT_HEIGHT]		with color outputs produced by input_generator("%d", GET_IMAGE_FROM_PNM) controled by input_controler();

input		image_left[INPUT_WIDTH][INPUT_HEIGHT]		with color outputs produced by input_generator("%d", GET_IMAGE_FROM_RBT) controled by input_controler();
input		image_right[INPUT_WIDTH][INPUT_HEIGHT]		with color outputs produced by input_generator("%d", GET_IMAGE_FROM_RBT) controled by input_controler();

#input		image_left[INPUT_WIDTH][INPUT_HEIGHT]		with color outputs produced by input_generator("%d", GET_IMAGE_TEST_STIMULUS) controled by input_controler();
#input		image_right[INPUT_WIDTH][INPUT_HEIGHT]		with color outputs produced by input_generator("%d", GET_IMAGE_TEST_STIMULUS) controled by input_controler();

############################################### Neuron Layers ##################################################
neuronlayer		nl_translated_image_left[NL_WIDTH][NL_HEIGHT] with color outputs;

neuronlayer		nl_simple_mono_right[NL_WIDTH][NL_HEIGHT]	with	greyscale_float outputs;
neuronlayer		nl_simple_mono_left[NL_WIDTH][NL_HEIGHT]	with	greyscale_float outputs;
neuronlayer		nl_simple_mono_right_q[NL_WIDTH][NL_HEIGHT]	with	greyscale_float outputs;
neuronlayer		nl_simple_mono_left_q[NL_WIDTH][NL_HEIGHT]	with	greyscale_float outputs;

neuronlayer		nl_simple_binocular[NL_WIDTH][NL_HEIGHT]	with	greyscale_float outputs;
neuronlayer		nl_simple_binocular_q[NL_WIDTH][NL_HEIGHT]	with	greyscale_float outputs;

neuronlayer		nl_complex_mono_right[NL_WIDTH][NL_HEIGHT]	with	greyscale_float outputs;
neuronlayer		nl_complex_mono_left[NL_WIDTH][NL_HEIGHT]	with	greyscale_float outputs;
neuronlayer		nl_complex_binocular[NL_WIDTH][NL_HEIGHT]	with	greyscale_float outputs;

neuronlayer		nl_mt[NL_WIDTH][NL_HEIGHT]	with	greyscale_float outputs;
neuronlayer		nl_mt_gaussian[NL_WIDTH][NL_HEIGHT]	with	greyscale_float outputs;

neuronlayer		nl_mt_gaussian_var[NL_WIDTH][NL_HEIGHT]	with	greyscale_float outputs;
neuronlayer		nl_mt_gaussian_map[NL_WIDTH][NL_HEIGHT]	with	greyscale_float outputs;
neuronlayer		nl_confidence_map[NL_WIDTH][NL_HEIGHT]	with	greyscale_float outputs;
neuronlayer		nl_disparity_map[NL_WIDTH][NL_HEIGHT]	with	greyscale_float outputs;

############################################### Outputs ########################################################
output		out_translated_image_left[NL_WIDTH][NL_HEIGHT];

output		out_simple_mono_right[NL_WIDTH][NL_HEIGHT];
output		out_simple_mono_left[NL_WIDTH][NL_HEIGHT];
output		out_simple_mono_right_q[NL_WIDTH][NL_HEIGHT];
output		out_simple_mono_left_q[NL_WIDTH][NL_HEIGHT];

# output		out_simple_binocular[NL_WIDTH][NL_HEIGHT];
# output		out_simple_binocular_q[NL_WIDTH][NL_HEIGHT];

# output		out_complex_mono_right[NL_WIDTH][NL_HEIGHT];
# output		out_complex_mono_left[NL_WIDTH][NL_HEIGHT];
# output		out_complex_binocular[NL_WIDTH][NL_HEIGHT];

output		out_mt[NL_WIDTH][NL_HEIGHT];
output		out_mt_gaussian[NL_WIDTH][NL_HEIGHT];

# output		out_mt_gaussian_var[NL_WIDTH][NL_HEIGHT];
# output		out_mt_gaussian_map[NL_WIDTH][NL_HEIGHT];
# output		out_confidence_map[NL_WIDTH][NL_HEIGHT];
output		out_disparity_map[NL_WIDTH][NL_HEIGHT];

################################## Connect Neuron Layers to Outputs #############################################
outputconnect	nl_translated_image_left to out_translated_image_left;

outputconnect	nl_simple_mono_right to out_simple_mono_right;
outputconnect	nl_simple_mono_left to out_simple_mono_left;
outputconnect	nl_simple_mono_right_q to out_simple_mono_right_q;
outputconnect	nl_simple_mono_left_q to out_simple_mono_left_q;

# outputconnect	nl_simple_binocular to out_simple_binocular;
# outputconnect	nl_simple_binocular_q to out_simple_binocular_q;

# outputconnect	nl_complex_mono_right to out_complex_mono_right;
# outputconnect	nl_complex_mono_left to out_complex_mono_left;
# outputconnect	nl_complex_binocular to out_complex_binocular;

outputconnect	nl_mt to out_mt;
outputconnect	nl_mt_gaussian to out_mt_gaussian;

# outputconnect	nl_mt_gaussian_var to out_mt_gaussian_var;
# outputconnect	nl_mt_gaussian_map to out_mt_gaussian_map;
# outputconnect	nl_confidence_map to out_confidence_map;
outputconnect	nl_disparity_map to out_disparity_map;

############################################### Filters #########################################################
#filter		image_left  with translate_filter("") producing nl_translated_image_left;

#biological_gabor_filter("%f %f %f %f %f %f %d %d %f", camera_opening_degree, cycles_per_degree, band_width, aspect_ratio, orientation, phase, shift, mapping, log_factor)

# === CELULAS SIMPLES MONOCULARES ===
#filter	image_right	with biological_gabor_filter ("%f %f %f %f %f %f %d %d %f %d", FOV_HORIZONTAL, CYCLES_PER_DEGREE, 2.0, 1.0, 0.0, -3.0*pi/4.0, 0, MAP_PLAN, LOG_FACTOR, KERNEL_2D)	producing nl_simple_mono_right;
#filter	image_right	with biological_gabor_filter ("%f %f %f %f %f %f %d %d %f %d", FOV_HORIZONTAL, CYCLES_PER_DEGREE, 2.0, 1.0, 0.0,     -pi/4.0, 0, MAP_PLAN, LOG_FACTOR, KERNEL_2D)	producing nl_simple_mono_right_q;
#filter	nl_translated_image_left	with biological_gabor_filter ("%f %f %f %f %f %f %d %d %f %d", FOV_HORIZONTAL, CYCLES_PER_DEGREE, 2.0, 1.0, 0.0,      pi/4.0, 0, MAP_PLAN, LOG_FACTOR, KERNEL_2D)	producing nl_simple_mono_left;
#filter	nl_translated_image_left	with biological_gabor_filter ("%f %f %f %f %f %f %d %d %f %d", FOV_HORIZONTAL, CYCLES_PER_DEGREE, 2.0, 1.0, 0.0,  3.0*pi/4.0, 0, MAP_PLAN, LOG_FACTOR, KERNEL_2D)	producing nl_simple_mono_left_q;

# === CELULA SIMPLES BINOCULAR ====
#filter	nl_simple_mono_right,	nl_simple_mono_left	with	robot_sum_filter ("")	producing	nl_simple_binocular;
#filter	nl_simple_mono_right_q,	nl_simple_mono_left_q	with	robot_sum_filter ("")	producing	nl_simple_binocular_q;

# === CELULA COMPLEXA MONOCULAR ====
#filter	nl_simple_mono_right,	nl_simple_mono_right_q	with	robot_complex_cell ("")	producing	nl_complex_mono_right;
#filter	nl_simple_mono_left,	nl_simple_mono_left_q	with	robot_complex_cell ("")	producing	nl_complex_mono_left;

# === CELULA COMPLEXA BINOCULAR ====
#filter	nl_simple_binocular, nl_simple_binocular_q with robot_complex_cell ("")		producing	nl_complex_binocular;

# === CELULA MT ====
#filter	nl_complex_mono_left, nl_complex_mono_right, nl_complex_binocular with robot_mt_cell ("%f", MT_SENSIBILITY)	producing	nl_mt;

 #filter	nl_simple_mono_right, nl_simple_mono_right_q, nl_simple_mono_left,  nl_simple_mono_left_q with robot_mt_cell_planar("%f", MT_SENSIBILITY) producing nl_mt;


# === V1_MT -> BIOLOGICAL_GABOR_FILTER + SUM_FILTER + COMPLEX_CELL + MT_CELL + GAUSSIAN_FILTER ====
# O V1_MT SUBSTITUI TODOS OS FILTROS QUE O COMPOE. USE-OS INDIVIDUALMENTE OU SOMENTE O V1_MT
filter	image_right, image_left		with v1_mt ("%f %f %f %f %f %f %d %f %f %d %f %f %d %f %f %d %d %f %d %f %d %f", 
	FOV_HORIZONTAL, CYCLES_PER_DEGREE, 2.0, 1.0, 
	0.0, -3.0*pi/4.0, 0, 
	0.0,     -pi/4.0, 0, 
	0.0,      pi/4.0, 0, 
        0.0,  3.0*pi/4.0, 0, 
	MAP_PLAN, LOG_FACTOR, KERNEL_2D, MT_SENSIBILITY, 25, 7.0)
	producing nl_mt_gaussian;


#filter	nl_mt with robot_gaussian_filter("%d %f", 25, 7.0) producing nl_mt_gaussian;
#filter	nl_mt with robot_gaussian_filter("%d %f", 9, 2.0) producing nl_mt_gaussian;
